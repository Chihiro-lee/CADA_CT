typedef unsigned char uint8_t;
typedef unsigned int uint16_t;
typedef unsigned long uint32_t;
typedef signed long int32_t;
typedef signed int int16_t;
typedef signed char int8_t;
typedef unsigned char bool;
typedef unsigned long long uint64_t;
const uint32_t key_set[1024] = {
    0x517eee5e,
    0x5bf51e12,
    0xec90db51,
    0x5f137902,
    0x5d0e3e73,
    0x4c701c24,
    0xd75f836b,
    0x576bdc54,
    0x8e189b5b,
    0xc64bf5a8,
    0x036d2aa2,
    0x63bf5f5f,
    0x6825f61a,
    0xbfe3a6bd,
    0xcbab6c7e,
    0x1e4f1957,
    0x4492dc43,
    0x097dcc60,
    0x25ef0a73,
    0xf258b6df,
    0x1cadaf55,
    0xdda07089,
    0x44a9cbd8,
    0xb7f05e6a,
    0x9f109f87,
    0x653043ad,
    0xb56d04df,
    0x2f29eb32,
    0x1b000e43,
    0x5c5bdb41,
    0xb3069878,
    0xc2eff1f4,
    0x154150b5,
    0x03a07a78,
    0xbabe32fb,
    0x963a2352,
    0x00b450bc,
    0x90e98646,
    0x4daa0360,
    0x2a7c3965,
    0xbab9dce4,
    0xaf1c9ac5,
    0x3e6cf2f6,
    0xd6820053,
    0x2f6a24c4,
    0x9fc7aa0b,
    0xb32896ca,
    0x0696dc68,
    0xa754e6b8,
    0x2eeb5460,
    0x0d9995f8,
    0xe336b262,
    0xf71ba749,
    0x108f8531,
    0x019808b5,
    0xacc3fe6f,
    0x7a1ec035,
    0x31fa52a7,
    0x994820ed,
    0xe693c4ac,
    0x71e8fc62,
    0x28fae879,
    0x774dc1f9,
    0xad7d8f0a,
    0x40765db3,
    0xf893b5b3,
    0xcf301b3e,
    0xc59ed767,
    0xc4701ed6,
    0x84d8b55e,
    0x8af209bb,
    0x25bbab30,
    0x3887a887,
    0x2600c00c,
    0xd168b38f,
    0xe2402332,
    0x8c924470,
    0xd29c13ee,
    0xb8e231aa,
    0xbdf9b325,
    0x66275378,
    0x0c287e63,
    0x77a640f4,
    0xbfaf2ff4,
    0x5f095f63,
    0x542d1681,
    0x2c9cb1a9,
    0x63a28fc7,
    0xaf422bd1,
    0xd91f4021,
    0xcfe25007,
    0xabef9559,
    0x73179b1d,
    0x0580352d,
    0xd2d810d9,
    0x01760297,
    0x21d69f5f,
    0xdb6e7941,
    0x9f7e6cf8,
    0x8ad9c1eb,
    0x53c00dbb,
    0xde401b00,
    0x636a4722,
    0xc70bc906,
    0xd4983eba,
    0x064ebee1,
    0x521ab9b1,
    0x84366f95,
    0x772111d2,
    0x8756fff7,
    0x7eb1642b,
    0xabba3318,
    0x506a5beb,
    0x3acbdcc4,
    0xa0ce0769,
    0x15046eaa,
    0x23dd7251,
    0xb0e87177,
    0x2211629f,
    0x915a96b1,
    0x221cc400,
    0x8b8e402b,
    0x1f466829,
    0xaed3e4eb,
    0x889b4413,
    0x16513785,
    0xd37379e8,
    0x320b869a,
    0x18ae0e42,
    0x9bcb8ebb,
    0xf74570ff,
    0xaff5c45d,
    0x7fe556c9,
    0x2e402666,
    0xdb7e0f13,
    0x4efe6b95,
    0x20d386bb,
    0xaf725b67,
    0xb8f50633,
    0x6dbdfaea,
    0xabff6643,
    0xdf6441ac,
    0xc27808a6,
    0x7370144a,
    0xc940e431,
    0xb7d3c934,
    0xb47368cf,
    0x4f5eef78,
    0x8868165f,
    0x920a89a7,
    0xd761c6eb,
    0x8a3bb5e2,
    0x8571304e,
    0xa977c66b,
    0x5fe2011c,
    0xbc946b2d,
    0xc0f518ad,
    0x5453af8c,
    0xbed24364,
    0xba1f56c7,
    0xef2ebd90,
    0x1a128a11,
    0xafb48907,
    0x772f3d5d,
    0x57d58e36,
    0x70546d6a,
    0x7aeb37e4,
    0x908c64ba,
    0x1439630f,
    0x2e19f9a9,
    0x2af0029d,
    0x9052ec41,
    0x27d07640,
    0x3f062e9b,
    0xc22fbbf3,
    0x7af90859,
    0x4ad77f96,
    0x399156fa,
    0x8cb3e5e8,
    0x4915c200,
    0xde9f73e7,
    0xeab7e036,
    0xb0ce52a5,
    0x6968d99b,
    0x4df9419a,
    0xd4516bab,
    0xb638d28e,
    0xed464b3b,
    0x3b20643a,
    0xa71c1316,
    0x90859b85,
    0x33ca4f6f,
    0x1e7949ae,
    0x20fc3b1a,
    0x86af33b4,
    0xa426f2cd,
    0x866099f8,
    0x7d6c61d0,
    0xfce91793,
    0x5cdc127d,
    0x7a3f59a2,
    0x64ee48c8,
    0x61581474,
    0xebe0cff6,
    0x65035803,
    0xfaf9d758,
    0xc9567f09,
    0x636f725d,
    0xf2d3c750,
    0xba6c3d61,
    0xd2a51d9b,
    0x54914592,
    0x60ce0afa,
    0x2661484b,
    0x402d8a84,
    0x78725549,
    0xeb2089c8,
    0x0359c4de,
    0xd2faafdc,
    0xaeb7b7ec,
    0x1a596963,
    0x23a4573c,
    0xb69b95c7,
    0x61f8c7d5,
    0xc133f237,
    0xaef779ef,
    0xcbaa9cfb,
    0x7d0dd225,
    0xdc644ad2,
    0xf358104d,
    0x8ea87bf9,
    0xc19b49e5,
    0x431424eb,
    0xbb3af168,
    0xebcc1721,
    0x3ce8eb64,
    0x72997915,
    0xa0ef21a9,
    0x5dd1b0bf,
    0xc78080d4,
    0x8dfe0150,
    0x4cc42f7f,
    0xfb9f8d32,
    0x911d053e,
    0x170d8125,
    0xf5790acf,
    0x7f65e083,
    0x37a0b715,
    0xc63274d7,
    0x74f50d57,
    0xddd75557,
    0xe2a8f5b7,
    0xcc01511a,
    0xb9bbc0aa,
    0x0a4f5285,
    0x454f9d8f,
    0x84e346e0,
    0x3ed583b0,
    0x2086a43e,
    0xcd01cf46,
    0x0437b97a,
    0x4cc081b7,
    0x7fd1efde,
    0xd6cd0e2d,
    0x7325e156,
    0xfb1baa00,
    0x1e5003c2,
    0x0bb3f1c5,
    0x0cb73348,
    0x862cd5cf,
    0x34ac102a,
    0xcf76f6a1,
    0xc868426d,
    0x5e13a57a,
    0x8d5e648b,
    0x98cac389,
    0x0e93cee1,
    0xa83270a5,
    0x2b31b88b,
    0x9133e486,
    0x86df235c,
    0x9769f5c0,
    0x8deaf963,
    0xcd7bd8a2,
    0x4f554f2d,
    0xe0a3394d,
    0xbd936eb3,
    0x6de338b5,
    0x95d6c16d,
    0x7a9e233f,
    0xe206e5b9,
    0x4f2dd25c,
    0xcd041cba,
    0xbf96a67d,
    0x3e57d0db,
    0x4b669260,
    0xd88dee50,
    0x3dbec595,
    0xac337603,
    0x9c33fbe5,
    0xdda3be4b,
    0xfa6d683b,
    0xa8cabfed,
    0x038b1683,
    0x14cab18c,
    0xeb9d75d8,
    0xc6ae76c6,
    0xf0f0c4e3,
    0xdc45bb25,
    0xe2b34270,
    0x819768df,
    0x8bacbc5f,
    0xd1dd4ace,
    0x7e917015,
    0x9f814ae1,
    0xe5512ae5,
    0x81c3a6a8,
    0xd317759d,
    0xa05d2805,
    0x0f09a02e,
    0xaaea9a34,
    0x8002a462,
    0x760560e0,
    0x52638b5e,
    0xa6d0a9f4,
    0x9aa8feb0,
    0x69725728,
    0x54ccd47a,
    0x178336a0,
    0x213ad734,
    0x951e8e38,
    0xcbac13b9,
    0x42457072,
    0xc5cdf64a,
    0x33b5429c,
    0x815c0af2,
    0xad70c166,
    0x2c72530c,
    0xae07911d,
    0xb8cc45e8,
    0x3923eae5,
    0xe59432f6,
    0x33a7d7a9,
    0xb007d3d5,
    0x09730fbb,
    0xe142a2d1,
    0x8bbb0404,
    0x02002105,
    0xe0559e64,
    0xd1166a4f,
    0x61dfa9e1,
    0x59c355fe,
    0x42b1c336,
    0xf6ecc967,
    0x1efe1004,
    0x16edbaeb,
    0xbd2c5ff8,
    0xee765069,
    0x59febee4,
    0x4350b2b8,
    0xcd6c2b05,
    0xf2c15aef,
    0xcb37fe4d,
    0x0640a735,
    0xa19c3d65,
    0x191259cc,
    0xb455b82e,
    0x69782947,
    0x7f8c1146,
    0x2454ec7e,
    0x01f9d55b,
    0x43b10209,
    0x64c21d30,
    0xe1f993c1,
    0xb9ae0cf6,
    0xcc96c55c,
    0x84c956b5,
    0xbfd1d82d,
    0x2b5b4f41,
    0xef8dbff9,
    0x50aff820,
    0xdb204f48,
    0x6b05526f,
    0x6bb5edfd,
    0xa6080d34,
    0x9bf49fd5,
    0x6f860021,
    0xd9b5c5b1,
    0xfa6a4f7c,
    0xab674be1,
    0xeca1d24b,
    0x3ed05dfe,
    0x92fffedd,
    0x3712f30d,
    0x182e53d3,
    0xdae8dd65,
    0xc9427ff3,
    0x7b114709,
    0xcfd132fa,
    0x4745c4db,
    0xaba93997,
    0x878b4ce6,
    0xcc04a4a3,
    0x7dc9410c,
    0xd8496c2f,
    0x20b62420,
    0xbe0af7dc,
    0x5dc4c67f,
    0x87dcca25,
    0x570dfbb2,
    0x1cc991cf,
    0x13e5c85d,
    0x19c46a71,
    0xf45bf10d,
    0xabb4552e,
    0x353b21d5,
    0x9526e54f,
    0xf2837a75,
    0x29fd15dd,
    0xe626e3d4,
    0x7a1d070b,
    0xcd68e2b9,
    0x5956e1e4,
    0xc5f940e5,
    0x1930499a,
    0x00237d80,
    0x819ffaca,
    0xb1dfc838,
    0xef9cba0f,
    0x418db650,
    0xe53c0008,
    0xb8a8a03d,
    0x49ed1465,
    0x9040fbfa,
    0x4599ddec,
    0xbe887564,
    0xefcb5f87,
    0xeb964eed,
    0x02013abd,
    0x37455204,
    0x1ce2d64c,
    0xeb49a1de,
    0xba30f217,
    0x883306ac,
    0x44758e03,
    0x3b7b8406,
    0x98c0cdcf,
    0x24e91ec7,
    0xb34a3d6e,
    0x2c53fdab,
    0x39f6d810,
    0x56f4311b,
    0x92a240c1,
    0x40d25a80,
    0xafa10866,
    0x3fc8a2fb,
    0x99445cf8,
    0x8e71638a,
    0x8081a572,
    0x51d9fbfe,
    0x7e8526e5,
    0x8a9d919f,
    0xc6b1e823,
    0x71d69b76,
    0x3a3b00cd,
    0xeabd1668,
    0x7ce45570,
    0xe2848a70,
    0xc1da8e63,
    0xbf62bf51,
    0x06b693ec,
    0x3a6e4945,
    0x54d87897,
    0xdab961cd,
    0x51b0055b,
    0x0a2e2a0e,
    0x87e7199f,
    0xebeb8ddf,
    0x4b4812a6,
    0x2b41edeb,
    0xda192723,
    0xa5e49677,
    0xbd9b87af,
    0xd704feef,
    0x6c3ecd9d,
    0x42f3541e,
    0x8a090caf,
    0xc24d18c9,
    0x7509e443,
    0x34c8376c,
    0x281d7dd6,
    0x92f30bdc,
    0xbda48c8d,
    0x0fdc6eac,
    0x89d8324c,
    0xaa9b922c,
    0xd90b9200,
    0x19421a74,
    0x2298fc8e,
    0x7db98367,
    0x64e70094,
    0xc1d53447,
    0x45b0e011,
    0x0f4caa76,
    0x3a1beae9,
    0x872b8958,
    0x00bf3250,
    0x2247fde6,
    0xad23402f,
    0x582437da,
    0x495d963e,
    0xae06b758,
    0x620dc5cd,
    0x4005c41b,
    0x910f9bc2,
    0xec619dbb,
    0x82d8b347,
    0xdc11e84b,
    0x84bd9159,
    0x92a8e478,
    0xc6c46b11,
    0xf342a1be,
    0xeba65ef2,
    0x4d7fcce0,
    0x60dcb54a,
    0x0edd234d,
    0xbbed3070,
    0xe891aef8,
    0x3bbc0eec,
    0x69f4c07a,
    0x11d7ece7,
    0xf4d1f90a,
    0x3b15404c,
    0x75057394,
    0x495b6b21,
    0xcc0f584d,
    0x8b7c2b7f,
    0x8a0413f8,
    0xd0cd9f3b,
    0x06b96798,
    0x963e980f,
    0xd6cc0ef4,
    0x663901d0,
    0xbfca4195,
    0x2ae18c21,
    0x26bbdd29,
    0x017ae687,
    0x7b2be89a,
    0xb4a9cc29,
    0x1dd8afe3,
    0xb1f6441e,
    0x2dc70bcb,
    0xe0e2f3dd,
    0x423814b9,
    0xc1765412,
    0xdf4c4b93,
    0xded88e1d,
    0xe3b76eb4,
    0xd7504003,
    0x4371e640,
    0x8663873b,
    0x6ae1a6f0,
    0xa848b58f,
    0x17b0167d,
    0xd78de84d,
    0xaa36c643,
    0x5a83431a,
    0x057be3a9,
    0x0a4197f9,
    0x4c9c6f89,
    0x6a3237bf,
    0xbdd5e525,
    0x3962fe94,
    0x2119d1a5,
    0x36700105,
    0x2af540c2,
    0x3c10eab4,
    0x127b136b,
    0x6c3a85ca,
    0xc81d4f73,
    0x4e0154c5,
    0xc460e89f,
    0x36918a64,
    0xce8b45ac,
    0x090b6fe4,
    0xc3a0645d,
    0x72305141,
    0x09c7df78,
    0x72c17fc7,
    0xc9826945,
    0xeaaf5f66,
    0x9678688d,
    0x4a3957aa,
    0x2f6c5050,
    0xae5a7425,
    0x8a306f0d,
    0x8682bdd5,
    0xd418fe59,
    0x2293639c,
    0x37d41c87,
    0x4135b81b,
    0x8ec4e101,
    0x4909828a,
    0xa9d86edc,
    0xff51f8a3,
    0x676968bc,
    0x43b3db1e,
    0xe0706929,
    0x3bb937fb,
    0xaf3cd391,
    0x32566404,
    0x72786592,
    0x37a3b710,
    0x0ca42e81,
    0xc9036d25,
    0x1d35f7ee,
    0x3de82a01,
    0x8d7f50be,
    0xd4ca9ca9,
    0xa68a6030,
    0x0e674b6f,
    0x48e45af6,
    0x0539cda1,
    0x398f274a,
    0x8884345c,
    0x5ff23ec7,
    0x45295fc0,
    0x2e1a7703,
    0xc1e64238,
    0xd2f92915,
    0x00654e9b,
    0x0fdaeda0,
    0x4e58fce3,
    0x8aca8866,
    0x337fc0d2,
    0xbe3b9122,
    0xe2ae7954,
    0x833fe053,
    0x2cf7e0c3,
    0xbf05cc1f,
    0x93ddb65e,
    0x32da0c48,
    0x576a74e4,
    0xf3ceec6d,
    0x2dbde79c,
    0x9e7f0682,
    0x2e13de54,
    0x3bc396ab,
    0xde2dc2f4,
    0x701cdd2d,
    0x87e955ea,
    0xd7bbabf6,
    0x046d29ca,
    0xeed6f9c9,
    0xd57adc09,
    0x40f72030,
    0xb7767712,
    0x6fb69145,
    0xc05525b0,
    0x2596de58,
    0x0a798c6a,
    0x32c0a0e2,
    0x56198015,
    0xf8c93ede,
    0x5e1a03ca,
    0xa3de117d,
    0x95da1b5c,
    0x2ff4ea2d,
    0x8d20870f,
    0xf121ba33,
    0x343be4ef,
    0x035a8143,
    0xb9957506,
    0x3505ee2c,
    0xab92aa61,
    0xe32d1ab4,
    0x2ec9ea2b,
    0x7f6e1974,
    0xe5ae970f,
    0x7aab3ed2,
    0xb3759c0b,
    0x012fbeed,
    0x37744291,
    0x99385cae,
    0x6f1e0e14,
    0x25be20f4,
    0xe5321943,
    0xf0473a0f,
    0xc2659a9b,
    0xbc09a7ad,
    0x8dfc1456,
    0xb011c9f8,
    0x86dc22bc,
    0x9c5a8d4c,
    0x1d3be4f3,
    0xc7e95fba,
    0xab23ecb8,
    0xe318bcb8,
    0x53d2ed7d,
    0x2905144d,
    0xb06217fd,
    0x230e559c,
    0xe7516f34,
    0xa4642e97,
    0x89515374,
    0x800b4746,
    0xa567d192,
    0x5f2c9c8b,
    0x1cf611d0,
    0xf6ff55a7,
    0x000d08e5,
    0x2ac4033e,
    0x1a53f14d,
    0xf1c1eaa7,
    0x56331e7d,
    0x6faadc7c,
    0x3b8f473b,
    0x19d9de9c,
    0xe10024df,
    0xd6efb25e,
    0xb3274468,
    0x11767b03,
    0xcb5846d8,
    0x947541ec,
    0xac7a9062,
    0x4933dcd6,
    0x1057087b,
    0x732b8cfe,
    0x2d69a78a,
    0x89f3e07c,
    0x11ff9d81,
    0x5500a45f,
    0x9746811a,
    0xcf974200,
    0x1e7fa980,
    0xb1bc2a65,
    0x1cd79abf,
    0x3e5e4759,
    0xd5deb19d,
    0x4ed3120d,
    0x1de61c56,
    0xc0a4d27f,
    0x1a577449,
    0x85324fcd,
    0xb4fd4485,
    0x95ca188a,
    0x3d9a77b1,
    0x16b61c01,
    0x26dcee43,
    0x276117f7,
    0xc020e8b2,
    0x71ff589f,
    0x327c14ad,
    0x0c2a8d13,
    0x5d6460eb,
    0x7db24f3f,
    0xd3b586e9,
    0x5317e737,
    0x4650b65c,
    0x7dabe44c,
    0xec352f78,
    0x6abcbda0,
    0xba7fa221,
    0xae1f72f8,
    0xdd4dc7f0,
    0x208f6be9,
    0xd35ab710,
    0xde3705fd,
    0x050af65e,
    0x2f312809,
    0x03034967,
    0x9d409c3d,
    0xdc4995e0,
    0x10c9ac99,
    0x24aa2185,
    0xe7696434,
    0x722f199d,
    0x882fb926,
    0x1cb177e6,
    0xeca97032,
    0x462a3ebc,
    0xb11c1bd7,
    0x222db98b,
    0x7d0cb107,
    0x965f08b2,
    0x7afefd29,
    0xcbec00df,
    0xf6383fda,
    0x5330f7ae,
    0xd39099d1,
    0xdd1b7696,
    0xffcb054e,
    0xe157914c,
    0x35daa2d4,
    0x6a113193,
    0xac20b5d3,
    0x184eed56,
    0xae74d359,
    0x6c6c8eb7,
    0xf6dc6b89,
    0xdded3b52,
    0x28c66e96,
    0x36792920,
    0x06effd94,
    0x5bb05ce5,
    0x41e2f5ee,
    0x0b958510,
    0xe5ff912c,
    0x992615bc,
    0xb1f2790c,
    0x2b4650f1,
    0xb263e307,
    0xb9860167,
    0xd2817088,
    0x5ef73f2b,
    0xe3ee5904,
    0xb1f9d3bc,
    0xa8ad2527,
    0x21edb24f,
    0xfecccffa,
    0x2ccc9c48,
    0x3d9e7567,
    0xa5c8a82c,
    0x0c1b2646,
    0x33f3b965,
    0xc8f9072d,
    0x66d3d26e,
    0x2516b033,
    0xddaef02a,
    0x1b9b7893,
    0xde997d52,
    0xe5eff275,
    0xa436a266,
    0xa28da7a9,
    0x7ee2f5fc,
    0x72337c37,
    0x7b1ad01a,
    0x4d246dc3,
    0xb48d3833,
    0xe4a41795,
    0x135560b3,
    0x87f7a907,
    0xcdac64c3,
    0xd8b1c348,
    0x37755296,
    0xf029fa99,
    0xe7317aea,
    0x4e1a3dff,
    0x5ec24963,
    0x5663cf67,
    0x29f2ff54,
    0x3bfc8ed6,
    0x43b8c5e8,
    0xe77e8760,
    0x62034cba,
    0x8464f69b,
    0x7bfa1f5c,
    0xd46f3650,
    0x8dc24278,
    0xd4f67ee6,
    0x19548378,
    0xd67a6830,
    0xb4122534,
    0x2d330233,
    0x195d2496,
    0xc1afbb4f,
    0xa6a8cce4,
    0x074a5cfe,
    0x70969a73,
    0x45efc9b3,
    0x1c0ec65e,
    0x70457b94,
    0x4513228d,
    0x07b00b3b,
    0x14798dc8,
    0xdcf58e2c,
    0xc95ad320,
    0x5d908f98,
    0xc0a66d7a,
    0x3e34fa00,
    0x61a2be57,
    0x16c59e30,
    0x27017a64,
    0xcf18321e,
    0x6315f859,
    0xb5051cf6,
    0xfedfa5b6,
    0x6fb44f97,
    0x1b1b1c0c,
    0x3cde038a,
    0x1e66f3f4,
    0xa7c5603a,
    0xcf4c5083,
    0x031b506f,
    0xe6a99a16,
    0x9a3dde21,
    0x42a69ff3,
    0xe3a66b28,
    0x663ee6c8,
    0xc1108a38,
    0x3cd3fe17,
    0xbb8bde4a,
    0x0be24e7f,
    0xe6adf641,
    0xab8ccfa1,
    0x7d13d4f9,
    0x545994b7,
    0xd09cf20b,
    0xb9e4db74,
    0x9d71be43,
    0xf4a7c594,
    0x39da0bac,
    0x4a0f9c82,
    0xdd30d07d,
    0x494e0adc,
    0xc82630fe,
    0x046ff886,
    0x91d3dfba,
    0xcae654ad,
    0xff1b21d7,
    0x78a9efa2,
    0x63385ec4,
    0x792302bf,
    0xa2eeddfb,
    0x020b5a63,
    0x88a59bde,
    0xbbeaf110,
    0x5c582eb0,
    0xf1296017,
    0xf45e2592,
    0x9be98102,
    0xff3a6b0f,
    0x25af57d9,
    0x80458fa9,
    0x252a4714,
    0x8e903573,
    0xeec6bfe0,
    0xcf3c8626,
    0x117cbe62,
    0x04fd4bfe,
    0x7ddc1fef,
    0xcb41638e,
    0x0513ceb6,
    0xb3af358e,
    0x8790885d,
    0x3463410d,
    0x4595c2eb,
    0x7b9d387b,
    0x92052868,
    0x27de4f12,
    0x44e1507f,
    0xd87f9992,
    0x6ab30893,
    0x1823e54a,
    0x319fe3f5,
    0xaaebfe09,
    0x4dab7243,
    0x924fa53a,
    0xa234e8dd,
    0x776ee56e,
    0x9e29b658,
    0xef4b31d6,
    0xab18bdb5,
    0x66b91025,
    0xfc91417c,
    0x8932dd38,
    0x3c010ee6,
    0x48358f3c,
    0x4d893fe5,
    0x83593ce7,
    0xc432b65e,
    0xcc6d33d6,
    0x4fdf2138,
    0xd96c9201,
    0x5350b728,
    0xf68d4ba7,
    0x96d51a5f,
    0x32a2f945,
    0xf6a8ed5d,
    0x93978b30,
    0xab5f56e4,
    0xaa707b6a,
    0x3c0715ee,
    0x8111e963,
    0x9891d6b3,
    0x9b4aee88,
    0x9ec7c452,
    0x5e18596e,
    0x12d775c4,
    0x46b7657e,
    0xd5a497ee,
    0x5fe1f990,
    0x14fd8c4c,
    0xa166b364,
    0xbe31b467,
    0x3778087b,
    0x827a9613,
    0x59260a50,
    0x57b4508e,
    0xfb066981,
    0x39aef1ac,
    0x25ab816c,
    0x0338e821,
    0x5a8bd1ac,
    0xdbec5b82,
    0xb2a5defd,
    0x55a56114,
    0x24e35127,
    0x422c8106,
    0xa11c7441,
    0x56d38c34,
    0x4b5eb53c,
    0xde87fe1a,
    0x99c94379,
    0x1f1fbdf1,
    0xc46f190e,
    0x50c8639a,
    0x4f7410e1,
    0x67e8b2ad,
    0xbe1bbdf1,
    0x8e17b726,
    0x68232e1b,
    0x0a893d73,
    0xa71a237b
};
const uint16_t appBottomText          = 0x4400;
const uint16_t appTopText             = 0xc3ff;

uint16_t* UCA1TXBUF              = 0x060E;
uint16_t* FCTL3                  = 0x0144;
uint16_t* FCTL1                  = 0x0140;

const char hex_chars[] = "0123456789ABCDEF";

uint16_t address_key;
uint32_t address_xor;
uint32_t address_sr;
uint16_t key_cnt;

uint16_t verify_count;
uint16_t write_count;

uint8_t write_count_bytes[2];
uint8_t combined_bytes[10];

uint16_t tmp_r4 = 0;
uint16_t tmp_r5 = 0;
uint16_t tmp_r6 = 0;

uint16_t* reg_r4;
uint16_t* reg_r5;
uint16_t* reg_r6;
uint16_t* reg_r8;
uint16_t* reg_sr;
uint16_t* reg_sp;
uint16_t* dest;

uint16_t reg_r4_value = 0;
uint32_t addr_in_reg_r4 = 0;
uint16_t* ptr_of_addr_in_reg_r4 = (uint16_t *)(&addr_in_reg_r4);


uint16_t* DFI_MAX         = 0x024000;
uint16_t* DFI_MIN         = 0x020000;
uint16_t* DFI_MAX_Orig    = 0x024000;

uint8_t* DFI_MAX_send         = 0x024000;
uint8_t* DFI_MIN_send         = 0x020000;
uint8_t* DFI_MAX_Orig_send    = 0x024000;
uint8_t* read_DFI_MAX    = 0x024000;
uint8_t read_input_bytes[1];

/* *****uart send model***** */

/*@ requires \valid(bytes + (0 .. 1));
    assigns bytes[0 .. 1];
    assigns *(bytes+ (0 .. 1));
    ensures bytes[0] == (uint8_t)((value >> 8) & 0xFF);
    ensures bytes[1] == (uint8_t)(value & 0xFF);
*/
void uint16_to_bytes(uint16_t value, uint8_t bytes[2]) {
    bytes[0] = (value >> 8) & 0xFF;
    bytes[1] = value & 0xFF;
}

/*@ requires \valid(bytes + (0 .. 3));
    assigns bytes[0 .. 3];
    assigns *(bytes+ (0 .. 3));
    ensures bytes[0] == (uint8_t)((value >> 24) & 0xFF);
    ensures bytes[1] == (uint8_t)((value >> 16) & 0xFF);
    ensures bytes[2] == (uint8_t)((value >> 8) & 0xFF);
    ensures bytes[3] == (uint8_t)(value & 0xFF);
*/
void uint32_to_bytes(uint32_t value, uint8_t bytes[4]) {
    bytes[0] = (value >> 24) & 0xFF;
    bytes[1] = (value >> 16) & 0xFF;
    bytes[2] = (value >> 8) & 0xFF;
    bytes[3] = value & 0xFF;
}

/*@ requires \valid(bytes + (0 .. 7));
    assigns bytes[0 .. 7];
    assigns *(bytes+ (0 .. 7));
    ensures bytes[0] == (uint8_t)((value >> 56) & 0xFF);
    ensures bytes[1] == (uint8_t)((value >> 48) & 0xFF);
    ensures bytes[2] == (uint8_t)((value >> 40) & 0xFF);
    ensures bytes[3] == (uint8_t)((value >> 32) & 0xFF);
    ensures bytes[4] == (uint8_t)((value >> 24) & 0xFF);
    ensures bytes[5] == (uint8_t)((value >> 16) & 0xFF);
    ensures bytes[6] == (uint8_t)((value >> 8) & 0xFF);
    ensures bytes[7] == (uint8_t)(value & 0xFF);
*/
void uint64_to_bytes(uint64_t value, uint8_t bytes[8]) {
    bytes[0] = (value >> 56) & 0xFF;
    bytes[1] = (value >> 48) & 0xFF;
    bytes[2] = (value >> 40) & 0xFF;
    bytes[3] = (value >> 32) & 0xFF;
    bytes[4] = (value >> 24) & 0xFF;
    bytes[5] = (value >> 16) & 0xFF;
    bytes[6] = (value >> 8) & 0xFF;
    bytes[7] = value & 0xFF;
}

/*@  assigns \nothing;  
     ensures high == \old(high);
     ensures low == \old(low);
*/
uint64_t combine_uint32_to_uint64(uint32_t high, uint32_t low) {
    return ((uint64_t)high << 32) | low;
}

/*@ requires \valid(UCA1TXBUF);
    assigns *UCA1TXBUF;
    ensures *UCA1TXBUF == byte;
*/
void uart_send_byte(uint8_t byte) {
    *UCA1TXBUF = byte;
}

/*@ requires 0 <= index < 16;
    assigns \nothing;
    ensures \result == hex_chars[index];
*/
uint8_t get_hex_char(uint8_t index) {
    return hex_chars[index];
}

/*@ requires \valid(data + (0 .. length-1)); 
    requires \forall integer k; 0 <= k < length ==> \valid(data + k);
    requires \valid(UCA1TXBUF);
    requires length-1 >= 0;
    requires \separated(data + (0 .. length-1), UCA1TXBUF);
    assigns *UCA1TXBUF;
    assigns data[0 .. length-1];
    assigns *(data+ (0 .. length-1));
    ensures *UCA1TXBUF == 0x20;
*/
void uart_send_hex_data(uint8_t *data, uint8_t length) {
    /*@ loop invariant 0 <= i <= length;
        loop invariant \forall integer j; 0 <= j < i ==> \valid(data + j);
        loop assigns i, *UCA1TXBUF;
        loop variant length - i;
    */
    for (uint8_t i = 0; i < length; i++) {
        //@ assert \valid(data + i);
        uint8_t index_high = (data[i] >> 4) & 0x0F;
        uint8_t index_low = data[i] & 0x0F;
        //@ assert 0 <= index_high < 16;
        //@ assert 0 <= index_low < 16;
        uint8_t c_high = get_hex_char(index_high);
        uint8_t c_low  = get_hex_char(index_low);
        uart_send_byte(c_high);
        uart_send_byte(c_low);
    }
    uart_send_byte(0x20); 
}

/* *****uart send model***** */


/* *****XOR API model***** */

/*@ 
   requires 0 <= key_cnt <= 1022;
   assigns key_cnt, address_key;
   ensures key_cnt == \old(key_cnt) + 1;
*/
void KeyGen(){
    if(key_cnt > 1023)
    	key_cnt = 0;
    key_cnt++;    
    address_key = key_set[key_cnt];
}

/*@ requires \valid(UCA1TXBUF);
    assigns combined_bytes[0 .. 9];
    assigns *UCA1TXBUF;
    ensures address_xor == \old(address_xor);
    ensures address_sr == \old(address_sr);
    ensures write_count == \old(write_count);
*/
void XorResult() { 

    uint64_t combined = combine_uint32_to_uint64(address_sr, address_xor);
    uint64_to_bytes(combined, combined_bytes);
    uint16_to_bytes(verify_count, combined_bytes+8);
    uart_send_hex_data(combined_bytes, 10);

    uart_send_byte(0x54);
    uart_send_byte(0x0A);
    uart_send_byte(0x0D); 
}

/*@
  requires 0 <= key_cnt <= 1022;
  requires \valid(dest);
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(UCA1TXBUF);
  requires \separated(UCA1TXBUF,reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, dest);
  assigns tmp_r4, tmp_r5, tmp_r6, write_count;
  assigns *reg_r4, *reg_r5, *reg_r6, *reg_r8, *reg_sr, *dest;
  assigns key_cnt, address_key, address_xor, address_sr, verify_count;
  assigns combined_bytes[0 .. 9];
  assigns *UCA1TXBUF;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures *reg_r6 == \old(*reg_r6);
  ensures *reg_r8 == write_count;
  ensures *reg_sr == *reg_r4;
  ensures *dest == *reg_r6;  
*/
void safe_call_fun(uint16_t* reg_r4, uint16_t* reg_r5,uint16_t* reg_r6,uint16_t* reg_r8, uint16_t* reg_sr) {

    tmp_r4 = *reg_r4;
    tmp_r6 = *reg_r6;
    tmp_r5 = *reg_r5;

    KeyGen();
    address_xor = (*reg_r6) ^ address_key;
    address_sr = (*reg_r4) ^ address_key;
    verify_count += 1;
    write_count = *reg_r8;
    XorResult();
    *reg_r8 = write_count;
    *reg_r4 = tmp_r4;
    *reg_r6 = tmp_r6;
    *reg_sr = *reg_r4;
    
    *dest = *reg_r6;   
}

/*@
  requires 0 <= key_cnt <= 1022;
  requires \valid(dest);
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(UCA1TXBUF);
  requires \separated(UCA1TXBUF,reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, dest);
  assigns tmp_r4, tmp_r5, tmp_r6, write_count;
  assigns *reg_r4, *reg_r5, *reg_r6, *reg_r8, *reg_sr, *dest;
  assigns key_cnt, address_key, address_xor, address_sr, verify_count;
  assigns combined_bytes[0 .. 9];
  assigns *UCA1TXBUF;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures *reg_r6 == \old(*reg_r6);
  ensures *reg_r8 == write_count;
  ensures *reg_sr == *reg_r4;
  ensures *dest == *reg_r6;   
*/
void safe_calla_fun(uint16_t* reg_r4, uint16_t* reg_r5,uint16_t* reg_r6,uint16_t* reg_r8, uint16_t* reg_sr) {

    tmp_r4 = *reg_r4;
    tmp_r6 = *reg_r6;
    tmp_r5 = *reg_r5;
    
    KeyGen();

    address_xor = (*reg_r6) ^ address_key;
    address_sr = (*reg_r4) ^ address_key;
    verify_count += 1;
    write_count = *reg_r8;
    XorResult();
    *reg_r8 = write_count;
    *reg_r4 = tmp_r4;
    *reg_r6 = tmp_r6;
    *reg_sr = *reg_r4;
    
    *dest = *reg_r6;   
}

/*@
  requires 0 <= key_cnt <= 1022;
  requires \valid(reg_r4);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(reg_sp);
  requires \valid(UCA1TXBUF);
  requires \separated(UCA1TXBUF, reg_r4, reg_r6, reg_r8, reg_sr, reg_sp);
  assigns tmp_r4, write_count;
  assigns *reg_r4, *reg_r6, *reg_sp, *reg_r8, *reg_sr;
  assigns key_cnt, address_key, address_xor, address_sr, verify_count;
  assigns combined_bytes[0 .. 9];
  assigns *UCA1TXBUF;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r6 == *reg_sp;
  ensures *reg_r8 == write_count;
  ensures *reg_sr == *reg_r4;
*/
void safe_ret_fun(uint16_t* reg_r4, uint16_t* reg_sp,uint16_t* reg_r8, uint16_t* reg_sr){
    tmp_r4 = *reg_r4;
    *reg_r6 = *reg_sp;
    KeyGen();
    address_xor = (*reg_r6) ^ address_key;
    address_sr = (*reg_r4) ^ address_key;
    verify_count += 1;
    write_count = *reg_r8;
    XorResult();
    *reg_r8 = write_count;
    *reg_r4 = tmp_r4;
    *reg_sr = *reg_r4;
    return;
}

/*@
  requires 0 <= key_cnt <= 1022;
  requires \valid(reg_r4);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(reg_sp);
  requires \valid(UCA1TXBUF);
  requires \separated(UCA1TXBUF, reg_r4, reg_r6, reg_r8, reg_sr, reg_sp);
  assigns tmp_r4, write_count;
  assigns *reg_r4, *reg_r6, *reg_sp, *reg_r8, *reg_sr;
  assigns key_cnt, address_key, address_xor, address_sr, verify_count;
  assigns combined_bytes[0 .. 9];
  assigns *UCA1TXBUF;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r6 == *reg_sp;
  ensures *reg_r8 == write_count;
  ensures *reg_sr == *reg_r4;
*/
void safe_reta_fun(uint16_t* reg_r4, uint16_t* reg_sp,uint16_t* reg_r8, uint16_t* reg_sr){
    tmp_r4 = *reg_r4;
    *reg_r6 = *reg_sp;
    KeyGen();
    address_xor = (*reg_r6) ^ address_key;
    address_sr = (*reg_r4) ^ address_key;
    verify_count += 1;
    write_count = *reg_r8;
    XorResult();
    *reg_r8 = write_count;
    *reg_r4 = tmp_r4;
    *reg_sr = *reg_r4;
    return;
}


/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_r6 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_mov_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 = *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_r6 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_movx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 = *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_xor_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 ^= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_xorx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 ^= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_add_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}


/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
*/
void write_addx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_addc_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_addcx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_dadd_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_daddx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 += *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_sub_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 -= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;
    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_subx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 -= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_subc_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 -= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;
    return; 
}

/*@
  requires \valid(reg_r4);
  requires \valid(reg_r5);
  requires \valid(reg_r6);
  requires \valid(reg_r8);
  requires \valid(reg_sr);
  requires \valid(FCTL3);
  requires \separated(reg_r4, reg_r5, reg_r6, reg_r8, reg_sr, FCTL3);
  assigns *reg_r6, *reg_r8, *reg_sr;
  ensures *reg_r4 == \old(*reg_r4);
  ensures *reg_r5 == \old(*reg_r5);
  ensures reg_r6 != FCTL3 ==> *reg_sr == *reg_r4;
  ensures 0 <= *reg_r8 <= 65536;
*/
void write_subcx_fun(uint16_t* reg_r4, uint16_t* reg_r5, uint16_t* reg_r6, uint16_t* reg_r8, uint16_t* reg_sr) {

    if (reg_r6 == FCTL3) {   
        return;  
    }
    
    *reg_r6 -= *reg_r5; 
    *reg_r8 = (*reg_r8) + 1;              
    *reg_sr = *reg_r4;

    return; 
}
/* *****XOR API model end***** */
